step 1:EPIT 的配置步骤
A:
1、设置 EPIT1 的时钟源:				[设置寄存器 EPIT1_CR 寄存器的 CLKSRC(bit25:24)位，选择 EPIT1 的时钟源]
2、设置分频值:						[设置寄存器 EPIT1_CR 寄存器的 PRESCALAR(bit15:4)位，设置分频值]
3、设置工作模式:					[设置寄存器 EPIT1_CR 的 RLD(bit3)位，设置 EPTI1 的工作模式]
4、设置计数器的初始值来源:			[设置寄存器 EPIT1_CR 的 ENMOD(bit1)位， 设置计数器的初始值来源]
5、使能比较中断:					[我们要使用到比较中断，因此需要设置寄存器 EPIT1_CR 的 OCIEN(bit2)位，使能比较中断]
B:
6、设置加载值和比较值:				[设置寄存器 EPIT1_LR 中的加载值和寄存器 EPIT1_CMPR 中的比较值，通过这两个寄存器就可以决定定时器的中断周期]
C:
7、EPIT1 中断设置和中断服务函数编写:[使能 GIC 中对应的 EPIT1 中断，注册中断服务函数，如果需要的话还可以设置中断优先级。最后编写中断服务函数]
D:
8、使能 EPIT1 定时器:				[配置好 EPIT1 以后就可以使能 EPIT1 了，通过寄存器 EPIT1_CR 的 EN(bit0)位来设置。
									[通过以上几步我们就配置好 EPIT 了，通过 EPIT 的比较中断来实现 LED0 的翻转]

step 2:代码分析:bsp_epittimer
A:设置分频值，清零CR寄存器 
	if(frac > 0XFFF)
		frac = 0XFFF;
	EPIT1->CR = 0;	
	
B:设置 EPIT1 的时钟源、设置分频值、设置工作模式、设置计数器的初始值来源、使能比较中断
    /* CR寄存器:
     * bit[25:24] 	01 时钟源选择Peripheral clock=66MHz
     * bit[15:4]  	frac 分频值
     * bit[3]:		1  当计数器到0的话从LR重新加载数值
     * bit[2]:		1  比较中断使能
     * bit[1]:    	1  初始计数值来源于LR寄存器值
     * bit[0]:    	0  先关闭EPIT1
     */
	/* 1000000 | 0xfff0 | 3 | 4 | 1 =100 FFF7 = 00[01] 0000 0000 [1111 1111 1111] [1][1][1][0] */
	EPIT1->CR = (1<<24 | frac << 4 | 1<<3 | 1<<2 | 1<<1);

C:设置加载值和比较值,决定定时器的中断周期
	/*  frac 是分频值， value 是加载值,中断频率，计算公式 Tout = ((frac +1 )* value) / Tclk 
	 * Tclk： EPIT1 的输入时钟频率(单位 Hz),根据 CR 寄存器，时钟源选择Peripheral clock=66MHz
	 * Tout： EPIT1 的溢出时间(单位 S) */
	EPIT1->LR = value;	/* 倒计数值 */
	EPIT1->CMPR	= 0;	/* 比较寄存器，当计数器值和此寄存器值相等的话就会产生中断 */
	
D:EPIT1 中断设置和中断服务函数
	/* 使能GIC中对应的中断 */
	GIC_EnableIRQ(EPIT1_IRQn);

	/* 注册中断服务函数 */
	system_register_irqhandler(EPIT1_IRQn, (system_irq_handler_t)epit1_irqhandler, NULL);
	
E:使能 EPIT1 定时器	
	EPIT1->CR |= 1<<0;	/* 使能EPIT1 */ 